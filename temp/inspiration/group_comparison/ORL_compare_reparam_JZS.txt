model {
  
  # Implementation of JZS priors for each decision model parameter

  #------ a_rew priors ------------------------------------------
  a.gamma_a_rew <- 1/2
  b.gamma_a_rew <- ngroups/2

  phi_a_rew ~ dgamma(0.01,0.01)

  invg_a_rew ~ dgamma(a.gamma_a_rew,b.gamma_a_rew)
  g_a_rew <- 1/invg_a_rew
  
  vari_a_rew <- (g_a_rew/phi_a_rew) * invSigma
  prec_a_rew <- 1/vari_a_rew
  
  beta0_a_rew ~ dnorm(0,1) 
  betaX_a_rew ~ dnorm(0,prec_a_rew)

  #------ a_pun priors ------------------------------------------
  a.gamma_a_pun <- 1/2
  b.gamma_a_pun <- ngroups/2
  
  phi_a_pun ~ dgamma(0.01,0.01)

  invg_a_pun ~ dgamma(a.gamma_a_pun,b.gamma_a_pun)
  g_a_pun <- 1/invg_a_pun
  
  vari_a_pun <- (g_a_pun/phi_a_pun) * invSigma
  prec_a_pun <- 1/vari_a_pun
  
  beta0_a_pun ~ dnorm(0,1)
  betaX_a_pun ~ dnorm(0,prec_a_pun)
  
  #------ K priors ------------------------------------------
  a.gamma_K <- 1/2
  b.gamma_K <- ngroups/2
  
  phi_K ~ dgamma(0.01,0.01)

  invg_K ~ dgamma(a.gamma_K,b.gamma_K)
  g_K <- 1/invg_K
  
  vari_K <- (g_K/phi_K) * invSigma
  prec_K <- 1/vari_K
  
  beta0_K ~ dnorm(0,1)
  betaX_K ~ dnorm(0,prec_K)

  #------ omega_f priors ------------------------------------------
  a.gamma_omega_f <- 1/2
  b.gamma_omega_f <- ngroups/2

  phi_omega_f ~ dgamma(0.01,0.01)

  invg_omega_f ~ dgamma(a.gamma_omega_f,b.gamma_omega_f)
  g_omega_f <- 1/invg_omega_f
  
  vari_omega_f <- (g_omega_f/phi_omega_f) * invSigma
  prec_omega_f <- 1/vari_omega_f
  
  beta0_omega_f ~ dnorm(0,1) 
  betaX_omega_f ~ dnorm(0,prec_omega_f)
  
  #------ omega_p priors ------------------------------------------
  a.gamma_omega_p <- 1/2
  b.gamma_omega_p <- ngroups/2

  phi_omega_p ~ dgamma(0.01,0.01)

  invg_omega_p ~ dgamma(a.gamma_omega_p,b.gamma_omega_p)
  g_omega_p <- 1/invg_omega_p
  
  vari_omega_p <- (g_omega_p/phi_omega_p) * invSigma
  prec_omega_p <- 1/vari_omega_p
  
  beta0_omega_p ~ dnorm(0,1) 
  betaX_omega_p ~ dnorm(0,prec_omega_p)

  #------ group level regressions ----------------------------
  for (n in 1:ngroups) {
  
    mu_a_rew_probit[n] <- beta0_a_rew + 
      betaX_a_rew*X[n] 

    mu_a_pun_probit[n] <- beta0_a_pun + 
      betaX_a_pun*X[n]

    mu_K_probit[n] <- beta0_K + 
      betaX_K*X[n]
    
    mu_omega_f[n] <- beta0_omega_f + 
      betaX_omega_f*X[n] 

    mu_omega_p[n] <- beta0_omega_p + 
      betaX_omega_p*X[n]
      
  
    # subject-level parameters
    #----------a_rew----------
    
    sigma_a_rew[n] ~ dunif(1,100)
    
    probit(mu_a_rew[n]) <- mu_a_rew_probit[n] # standardisation of rate estimate mean - probit link
    
    shape1_a_rew[n] <- (mu_a_rew[n]) * sigma_a_rew[n]
    shape2_a_rew[n] <- (1 - mu_a_rew[n]) * sigma_a_rew[n]
    
    #----------a_pun----------
    
    sigma_a_pun[n] ~ dunif(1,100)
    
    probit(mu_a_pun[n]) <- mu_a_pun_probit[n] # standardisation of rate estimate mean - probit link
    
    shape1_a_pun[n] <- (mu_a_pun[n]) * sigma_a_pun[n]
    shape2_a_pun[n] <- (1 - mu_a_pun[n]) * sigma_a_pun[n]
    
    #----------K----------
    
    sigma_K[n] ~ dunif(1,100)
    
    probit(mu_K[n]) <- mu_K_probit[n] # standardisation of rate estimate mean - probit link
    
    shape1_K[n] <- (mu_K[n]) * sigma_K[n]
    shape2_K[n] <- (1 - mu_K[n]) * sigma_K[n]
  
    #----------omega_f----------
    lambda_omega_f[n] ~ dgamma(.1,.1) 
    
    #----------omega_p----------
    lambda_omega_p[n] ~ dgamma(.1,.1) 
    
  }
  
  #----------- Control model -------------------------------------------
  for (s in 1:nsubs_ctr) {

    #----------rho----------
    a_rew_ctr[s] ~ dbeta(shape1_a_rew[1], shape2_a_rew[1])
    a_pun_ctr[s] ~ dbeta(shape1_a_pun[1], shape2_a_pun[1])
    K[1,s]  ~ dbeta(shape1_K[1], shape2_K[1]) 
    K_ctr[s] <- K[1,s] * 5  # cf. Haines et al.
    theta_ctr[s] <- 1# ~ dunif(0,2)
    omega_f_ctr[s] ~ dnorm(mu_omega_f[1],lambda_omega_f[1])
    omega_p_ctr[s] ~ dnorm(mu_omega_p[1],lambda_omega_p[1])
  
    #------ set t1 model variables --------------------------
      
    Ev_ctr[s,1,1] <- 0
    Ev_ctr[s,1,2] <- 0
    Ev_ctr[s,1,3] <- 0
    Ev_ctr[s,1,4] <- 0
      
    Ef_ctr[s,1,1] <- 0
    Ef_ctr[s,1,2] <- 0
    Ef_ctr[s,1,3] <- 0
    Ef_ctr[s,1,4] <- 0
      
    PS_ctr[s,1,1] <- 1
    PS_ctr[s,1,2] <- 1
    PS_ctr[s,1,3] <- 1
    PS_ctr[s,1,4] <- 1

    p_ctr[s,1,1] <- .25
    p_ctr[s,1,2] <- .25
    p_ctr[s,1,3] <- .25
    p_ctr[s,1,4] <- .25

    for (t in 2:ntrials_ctr[s]) {
      
      #this is imortant mention this as constructing model
      signX_ctr[s,t] <- ifelse(X_ctr[s,t-1]<0,-1,1)
      
      for (d in 1:4) {
        
        # -------- Updating expected values ------------------------
        Ev_update_ctr[s,t,d] <- ifelse(X_ctr[s,t-1]>=0,
                                  Ev_ctr[s,t-1,d] + a_rew_ctr[s]*((X_ctr[s,t-1]) - Ev_ctr[s,t-1,d]), 
                                  Ev_ctr[s,t-1,d] + a_pun_ctr[s]*((X_ctr[s,t-1]) - Ev_ctr[s,t-1,d])
        )
                              
        Ev_ctr[s,t,d] <- ifelse(d==x_ctr[s,t-1],Ev_update_ctr[s,t,d],Ev_ctr[s,t-1,d])
        
        # -------- Updating expected frequencies ------------------------
        #update expected frequencies for ALL decks - AS IF THERE WERE ALL CHOSEN
        Ef_cho_ctr[s,t,d] <- ifelse(X_ctr[s,t-1]>=0, 
                                Ef_ctr[s,t-1,d] + a_rew_ctr[s]*(signX_ctr[s,t] - Ef_ctr[s,t-1,d]),
                                Ef_ctr[s,t-1,d] + a_pun_ctr[s]*(signX_ctr[s,t] - Ef_ctr[s,t-1,d])
        )
        
        #update expected frequencies for ALL decks - AS IF THEY WERE ALL UNCHOSEN. 
        Ef_not_ctr[s,t,d] <- ifelse(X_ctr[s,t-1]>=0, 
                                Ef_ctr[s,t-1,d] + a_pun_ctr[s]*(-(signX_ctr[s,t]/3) - Ef_ctr[s,t-1,d]),
                                Ef_ctr[s,t-1,d] + a_rew_ctr[s]*(-(signX_ctr[s,t]/3) - Ef_ctr[s,t-1,d])
        ) 
        
        #copy appropriate values to ef variable
        Ef_ctr[s,t,d] <- ifelse(d==x_ctr[s,t-1],Ef_cho_ctr[s,t,d],Ef_not_ctr[s,t,d])  
        #------------------------------------------------------------------
        
        #ifelse needed to disctiminate chosen and unchosen decks
        PS_ctr[s,t,d] <- ifelse(x_ctr[s,t-1]==d,1/(1+K_ctr[s]),PS_ctr[s,t-1,d]/(1+K_ctr[s]))
        
        V_ctr[s,t,d] <- Ev_ctr[s,t,d] + (Ef_ctr[s,t,d]*omega_f_ctr[s]) + (PS_ctr[s,t,d]*omega_p_ctr[s])
        
        exp_p_ctr[s,t,d] <- exp(theta_ctr[s]*V_ctr[s,t,d])
        
      }
      
      for (d in 1:4) {
        p_ctr[s,t,d] <- exp_p_ctr[s,t,d]/sum(exp_p_ctr[s,t,])
      }
        
      x_ctr[s,t] ~ dcat(p_ctr[s,t,])
      
    }
  }




  ###################################################
  #-------- opioid model----------------------------
  ###################################################
  for (s in 1:nsubs_opi) {

    a_rew_opi[s] ~ dbeta(shape1_a_rew[2], shape2_a_rew[2])
    a_pun_opi[s] ~ dbeta(shape1_a_pun[2], shape2_a_pun[2])
    K[2,s] ~ dbeta(shape1_K[2], shape2_K[2])
    K_opi[s] <- K[2,s] * 5  # cf. Haines et al.
    theta_opi[s] <- 1# ~ dunif(0,2)
    omega_f_opi[s] ~ dnorm(mu_omega_f[2],lambda_omega_f[2])
    omega_p_opi[s] ~ dnorm(mu_omega_p[2],lambda_omega_p[2])
  
    #------ set t1 model variables --------------------------
      
    Ev_opi[s,1,1] <- 0
    Ev_opi[s,1,2] <- 0
    Ev_opi[s,1,3] <- 0
    Ev_opi[s,1,4] <- 0
      
    Ef_opi[s,1,1] <- 0
    Ef_opi[s,1,2] <- 0
    Ef_opi[s,1,3] <- 0
    Ef_opi[s,1,4] <- 0
      
    PS_opi[s,1,1] <- 1
    PS_opi[s,1,2] <- 1
    PS_opi[s,1,3] <- 1
    PS_opi[s,1,4] <- 1

    p_opi[s,1,1] <- .25
    p_opi[s,1,2] <- .25
    p_opi[s,1,3] <- .25
    p_opi[s,1,4] <- .25

    for (t in 2:ntrials_opi[s]) {
      
      #this is imortant mention this as constructing model
      signX_opi[s,t] <- ifelse(X_opi[s,t-1]<0,-1,1)
      
      for (d in 1:4) {
        
        # -------- Updating expected values ------------------------
        Ev_update_opi[s,t,d] <- ifelse(X_opi[s,t-1]>=0,
                                  Ev_opi[s,t-1,d] + a_rew_opi[s]*((X_opi[s,t-1]) - Ev_opi[s,t-1,d]), 
                                  Ev_opi[s,t-1,d] + a_pun_opi[s]*((X_opi[s,t-1]) - Ev_opi[s,t-1,d])
        )
                              
        Ev_opi[s,t,d] <- ifelse(d==x_opi[s,t-1],Ev_update_opi[s,t,d],Ev_opi[s,t-1,d])
        
        # -------- Updating expected frequencies ------------------------
        #update expected frequencies for ALL decks - AS IF THERE WERE ALL CHOSEN
        Ef_cho_opi[s,t,d] <- ifelse(X_opi[s,t-1]>=0, 
                                Ef_opi[s,t-1,d] + a_rew_opi[s]*(signX_opi[s,t] - Ef_opi[s,t-1,d]),
                                Ef_opi[s,t-1,d] + a_pun_opi[s]*(signX_opi[s,t] - Ef_opi[s,t-1,d])
        )
        
        #update expected frequencies for ALL decks - AS IF THEY WERE ALL UNCHOSEN. 
        Ef_not_opi[s,t,d] <- ifelse(X_opi[s,t-1]>=0, 
                                Ef_opi[s,t-1,d] + a_pun_opi[s]*(-(signX_opi[s,t]/3) - Ef_opi[s,t-1,d]),
                                Ef_opi[s,t-1,d] + a_rew_opi[s]*(-(signX_opi[s,t]/3) - Ef_opi[s,t-1,d])
        ) 
        
        #copy appropriate values to ef variable
        Ef_opi[s,t,d] <- ifelse(d==x_opi[s,t-1],Ef_cho_opi[s,t,d],Ef_not_opi[s,t,d])  
        #------------------------------------------------------------------
        
        #ifelse needed to disctiminate chosen and unchosen decks
        PS_opi[s,t,d] <- ifelse(x_opi[s,t-1]==d,1/(1+K_opi[s]),PS_opi[s,t-1,d]/(1+K_opi[s]))
        
        V_opi[s,t,d] <- Ev_opi[s,t,d] + Ef_opi[s,t,d]*omega_f_opi[s] + PS_opi[s,t,d]*omega_p_opi[s]
        
        exp_p_opi[s,t,d] <- exp(theta_opi[s]*V_opi[s,t,d])
        
      }
      
      for (d in 1:4) {
        p_opi[s,t,d] <- exp_p_opi[s,t,d]/sum(exp_p_opi[s,t,])
      }
        
      x_opi[s,t] ~ dcat(p_opi[s,t,])
      
    }
  }


}