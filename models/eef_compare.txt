model {
  # ============================================================================
  # EEF Comparison Model
  # ============================================================================
  
  # --- Priors ---
  # theta (Sensitivity)
  mu_theta    ~ dnorm(0.5, 1) T(0, 1)
  alpha_theta ~ dnorm(0, 1)
  
  # lambda (Decay)
  mu_lambda    ~ dnorm(0.5, 1) T(0, 1)
  alpha_lambda ~ dnorm(0, 1)
  
  # phi (Exploration)
  mu_phi    ~ dnorm(0, 0.25) T(-5, 5) # Wide prior, centered 0
  alpha_phi ~ dnorm(0, 1)
  
  # cons (Consistency)
  mu_cons    ~ dnorm(1, 1) T(0, 5)
  alpha_cons ~ dnorm(0, 1)
  
  # Precisions
  lambda_theta_g1 ~ dgamma(1, 0.1)
  lambda_lambda_g1 ~ dgamma(1, 0.1)
  lambda_phi_g1    ~ dgamma(1, 0.1)
  lambda_cons_g1   ~ dgamma(1, 0.1)

  lambda_theta_g2 ~ dgamma(1, 0.1)
  lambda_lambda_g2 ~ dgamma(1, 0.1)
  lambda_phi_g2    ~ dgamma(1, 0.1)
  lambda_cons_g2   ~ dgamma(1, 0.1)

  # ============================================================================
  # GROUP 1
  # ============================================================================
  for (s in 1:nsubs_g1) {
    theta_g1[s]  ~ dnorm(mu_theta - alpha_theta/2, lambda_theta_g1) T(0, 1)
    lambda_g1[s] ~ dnorm(mu_lambda - alpha_lambda/2, lambda_lambda_g1) T(0, 1)
    phi_g1[s]    ~ dnorm(mu_phi - alpha_phi/2, lambda_phi_g1) T(-5, 5)
    cons_g1[s]   ~ dnorm(mu_cons - alpha_cons/2, lambda_cons_g1) T(0, 5)
    
    C_g1[s] <- pow(3, cons_g1[s]) - 1

    for (d in 1:4) {
      Exploit_g1[s,1,d] <- 0
      Explore_g1[s,1,d] <- 0
    }
    
    # t=1: Logic needs to handle t=1 choice if X and x are provided?
    # Loop usually starts at t=2. 
    # Let's assume t=1 choice provided, update logic runs for t=2..N.
    
    for (t in 2:ntrials_g1[s]) {
      # Outcomes
      u_g1[s,t] <- ifelse(X_g1[s,t-1] >= 0,
                          pow(abs(X_g1[s,t-1]), theta_g1[s]),
                          -1 * pow(abs(X_g1[s,t-1]), theta_g1[s]))
      
      for (d in 1:4) {
        # Exploit Update
        Exploit_g1[s,t,d] <- ifelse(d == x_g1[s,t-1],
                                    (1 - lambda_g1[s]) * Exploit_g1[s,t-1,d] + lambda_g1[s] * u_g1[s,t],
                                    (1 - lambda_g1[s]) * Exploit_g1[s,t-1,d])
        
        # Explore Update (Reset Rule)
        Explore_g1[s,t,d] <- ifelse(d == x_g1[s,t-1],
                                    0,
                                    (1 - lambda_g1[s]) * Explore_g1[s,t-1,d] + lambda_g1[s] * phi_g1[s])
                                    
        V_g1[s,t,d] <- Exploit_g1[s,t,d] + Explore_g1[s,t,d]
        exp_p_g1[s,t,d] <- exp(C_g1[s] * V_g1[s,t,d])
      }
      x_g1[s,t] ~ dcat(exp_p_g1[s,t,] / sum(exp_p_g1[s,t,]))
    }
  }
  
  # ============================================================================
  # GROUP 2
  # ============================================================================
  for (s in 1:nsubs_g2) {
    theta_g2[s]  ~ dnorm(mu_theta + alpha_theta/2, lambda_theta_g2) T(0, 1)
    lambda_g2[s] ~ dnorm(mu_lambda + alpha_lambda/2, lambda_lambda_g2) T(0, 1)
    phi_g2[s]    ~ dnorm(mu_phi + alpha_phi/2, lambda_phi_g2) T(-5, 5)
    cons_g2[s]   ~ dnorm(mu_cons + alpha_cons/2, lambda_cons_g2) T(0, 5)
    
    C_g2[s] <- pow(3, cons_g2[s]) - 1

    for (d in 1:4) {
      Exploit_g2[s,1,d] <- 0
      Explore_g2[s,1,d] <- 0
    }
    
    for (t in 2:ntrials_g2[s]) {
      u_g2[s,t] <- ifelse(X_g2[s,t-1] >= 0,
                          pow(abs(X_g2[s,t-1]), theta_g2[s]),
                          -1 * pow(abs(X_g2[s,t-1]), theta_g2[s]))
      
      for (d in 1:4) {
        Exploit_g2[s,t,d] <- ifelse(d == x_g2[s,t-1],
                                    (1 - lambda_g2[s]) * Exploit_g2[s,t-1,d] + lambda_g2[s] * u_g2[s,t],
                                    (1 - lambda_g2[s]) * Exploit_g2[s,t-1,d])
                                    
        Explore_g2[s,t,d] <- ifelse(d == x_g2[s,t-1],
                                    0,
                                    (1 - lambda_g2[s]) * Explore_g2[s,t-1,d] + lambda_g2[s] * phi_g2[s])
                                    
        V_g2[s,t,d] <- Exploit_g2[s,t,d] + Explore_g2[s,t,d]
        exp_p_g2[s,t,d] <- exp(C_g2[s] * V_g2[s,t,d])
      }
      x_g2[s,t] ~ dcat(exp_p_g2[s,t,] / sum(exp_p_g2[s,t,]))
    }
  }
}
