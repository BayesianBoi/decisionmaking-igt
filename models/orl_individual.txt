# ORL for single subject - used in PPC

model {
  
  # priors - same bounds as hierarchical
  a_rew ~ dnorm(0, 1)T(0,1)     # reward learning
  a_pun ~ dnorm(0, 1)T(0,1)     # Learning rate for punishments
  K ~ dnorm(0, 1)T(0,)          # Decay parameter
  theta <- 1                     # Fixed to 1 (matching hierarchical)
  omega_f ~ dnorm(0, .1)        # Frequency weight
  omega_p ~ dnorm(0, .1)        # Perseverance weight
  
  # Initialize trial 1
  Ev[1,1] <- 0
  Ev[1,2] <- 0
  Ev[1,3] <- 0
  Ev[1,4] <- 0
  
  Ef[1,1] <- 0
  Ef[1,2] <- 0
  Ef[1,3] <- 0
  Ef[1,4] <- 0
  
  PS[1,1] <- 1  # Match hierarchical (PS = 1)
  PS[1,2] <- 1
  PS[1,3] <- 1
  PS[1,4] <- 1
  
  p[1,1] <- .25
  p[1,2] <- .25
  p[1,3] <- .25
  p[1,4] <- .25
  
  for (t in 2:ntrials) {
    
    # Getting the "sign" of the payoff from the previous choice
    signX[t] <- ifelse(X[t-1] < 0, -1, 1)
    
    for (d in 1:4) {
      
        # EV update
      Ev_update[t,d] <- ifelse(X[t-1] >= 0,
                               Ev[t-1,d] + a_rew * (X[t-1] - Ev[t-1,d]), 
                               Ev[t-1,d] + a_pun * (X[t-1] - Ev[t-1,d])
      )
      
      Ev[t,d] <- ifelse(d == x[t-1], Ev_update[t,d], Ev[t-1,d])
      
        # win frequency
      # Update expected frequencies for ALL decks - AS IF THEY WERE ALL CHOSEN
      Ef_cho[t,d] <- ifelse(X[t-1] >= 0, 
                            Ef[t-1,d] + a_rew * (signX[t] - Ef[t-1,d]),
                            Ef[t-1,d] + a_pun * (signX[t] - Ef[t-1,d])
      )
      
      # Update expected frequencies for ALL decks - AS IF THEY WERE ALL UNCHOSEN (reversal learning)
      Ef_not[t,d] <- ifelse(X[t-1] >= 0, 
                            Ef[t-1,d] + a_pun * (-(signX[t]/3) - Ef[t-1,d]),
                            Ef[t-1,d] + a_rew * (-(signX[t]/3) - Ef[t-1,d])
      )
      
      # Copy appropriate values to Ef variable
      Ef[t,d] <- ifelse(d == x[t-1], Ef_cho[t,d], Ef_not[t,d])
      
      # Perseverance
      PS[t,d] <- ifelse(x[t-1] == d, 1/(1+K), PS[t-1,d]/(1+K))
      
      # Total value
      V[t,d] <- Ev[t,d] + Ef[t,d] * omega_f + PS[t,d] * omega_p
      
      exp_p[t,d] <- exp(theta * V[t,d])
    }
    
    for (d in 1:4) {
      p[t,d] <- exp_p[t,d] / sum(exp_p[t,])
    }
    
    x[t] ~ dcat(p[t,])
  }
}
